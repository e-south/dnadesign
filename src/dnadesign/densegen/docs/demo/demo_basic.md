
## DenseGen demo

This demo runs inside a packaged workspace that already contains inputs and a `config.yaml`. The workspace design dense-arrays associated with three regulators (LexA, BaeR, and CpxR).

---

### Contents

1. [Prereqs](#prereqs)
2. [Enter the demo workspace](#1-enter-the-demo-workspace)
3. [Validate config + solver](#2-validate-config-solver)
4. [Build Stage‑A pools](#3-build-stagea-pools)
5. [Run generation](#4-run-generation)
6. [Plot](#5-plot)
7. [Report (optional)](#6-report-optional)
8. [Reset the demo (optional)](#7-reset-the-demo-optional)
10. [Where outputs go](#where-outputs-go)
11. [Common troubleshooting](#common-troubleshooting)
12. [Next steps](#next-steps)

---

## Prereqs

You need:

1) **Python deps** (DenseGen + dependencies)
2) **MEME Suite** available so `fimo` is on PATH
3) A **solver backend** (e.g., CBC, GUROBI) that your dense-arrays install can see

From the repo root, sync Python dependencies and system tools:

```bash
uv sync --locked
pixi install
pixi run fimo --version
```

---

## Demo intent (LexA, CpxR, BaeR + background)

This demo builds 60‑bp minimal promoters with fixed σ70 −35/−10 hexamers and a
16–20 bp spacer. It models two condition‑linked regulator groups and a neutral
background pool, then generates monotypic/heterotypic libraries to explore logic‑like
combinations.

Key pieces:

- **Ethanol response group**: CpxR + BaeR motifs (plan name `ethanol`, group name
  `ethanol_response`).
- **Ciprofloxacin response group**: LexA motif (plan name `ciprofloxacin`, group
  name `ciprofloxacin_response`).
- **Neutral background pool**: 16–20 bp sequences generated by negative selection
  against LexA/CpxR/BaeR PWMs (FIMO). Any FIMO hit is rejected, and canonical
  −35/−10 kmers (`TTGACA`, `TATAAT`) are forbidden inside background parts.

Plan structure (plan‑scoped pools via `include_inputs`):

- `controls`: background only (neutral promoters, no TFBS).
- `ethanol`: CpxR/BaeR + background (monotypic A‑like; no LexA).
- `ciprofloxacin`: LexA + background (monotypic B‑like; no CpxR/BaeR).
- `ethanol_ciprofloxacin`: LexA + CpxR/BaeR + background (heterotypic A+B).

Stage‑B sampling uses `tf_balanced` across the plan pool. We do **not** require
both CpxR and BaeR in every ethanol sequence; instead, uniform sampling + solver
constraints let diverse architectures emerge without forcing contrived co‑occurrence.

Post‑assembly validation rejects any extra `TTGACA`/`TATAAT` outside the fixed
promoter windows to prevent accidental σ70 motifs across part boundaries.

Workspace + runner setup:

```bash
# Option A: cd into the workspace
cd src/dnadesign/densegen/workspaces/demo_meme_three_tfs  # enter demo workspace
CONFIG="$PWD/config.yaml"  # point to workspace config

# Option B: run from anywhere in the repo
CONFIG=src/dnadesign/densegen/workspaces/demo_meme_three_tfs/config.yaml  # config path from repo root

# Choose a runner (pixi is the default in this repo; uv is optional).
# If `dense` is already an alias, remove it before defining the function.
unalias dense 2>/dev/null
dense() { pixi run dense -- "$@"; }  # convenience wrapper

# Optional: uv-only wrapper
# dense() { uv run dense "$@"; }

# From here on, commands use $CONFIG for clarity; if you're in the workspace, you can omit -c.
```

If you want DenseGen to verify your solver is reachable, `dense validate-config --probe-solver -c "$CONFIG"` does that (step 2).

> After you set `CONFIG` and the `dense()` wrapper, you can reset outputs and run the full path:

```bash
# Remove outputs to start the demo fresh
dense campaign-reset -c "$CONFIG"
```

---

### 1. Enter the demo workspace

This folder is a self-contained workspace: it has a `config.yaml` plus `inputs/` and an `outputs/` root.

Optional, but useful: print what the workspace thinks it will use.

```bash
dense inspect inputs -c "$CONFIG"
dense inspect plan -c "$CONFIG"
dense inspect config -c "$CONFIG"
```

Those inspection commands are “read-only” and are the fastest way to confirm:

* which inputs are wired (and whether pools/libraries already exist),
* what plan items will run (quota/fraction resolution),
* which solver backend + strategy is configured.

---

### 2. Validate config + solver

```bash
dense validate-config --probe-solver -c "$CONFIG"
```

What this does:

* **Schema validation**: unknown keys and invalid values are errors.
* **Path sanity**: ensures paths resolve correctly (relative to `config.yaml`).
* **Solver probe (optional)**: verifies your configured backend is available.

---

### 3. Build Stage‑A pools

Stage‑A expects PWM artifact JSONs in the Cruncher export format. This demo ships prepopulated artifacts for **lexA**, **cpxR**, and **baeR** under `inputs/motif_artifacts/`. If you need to regenerate them (or understand the source mix), follow the Cruncher handoff workflow:

* `../workflows/cruncher_pwm_pipeline.md`

Provenance highlights (see the Cruncher workflow for full details):

* **LexA + CpxR**: local DAP‑seq MEME files from primary literature (loaded via the demo Cruncher workspace).
* **BaeR**: processed ChIP‑exo binding sites FASTA from Choudhary et al. 2020 (DOI: 10.1128/mSystems.00980-20) in the sibling repo `dnadesign-data/primary_literature/Choudhary_et_al/processed/BaeR_binding_sites.fasta`.
* RegulonDB curated sites can be merged as a supplemental source (optional in the Cruncher workflow).

That workflow uses MEME with **OOPS** (plus the `addone` prior) so sparse site sets produce stable PWMs without post-processing.

```bash
dense stage-a build-pool --fresh -c "$CONFIG"
```

> Without `--fresh`, `dense stage-a build-pool` appends *new unique* TFBS into an existing pool by default.

To plot Stage‑A diagnostics right away:

```bash
dense plot --only stage_a_summary -c "$CONFIG"
```

What Stage‑A is doing:

* For PWM-backed inputs, Stage‑A generates candidate sites, scores them with **FIMO log‑odds** (forward strand only), applies eligibility rules, deduplicates by your configured uniqueness key (commonly `core` for PWM inputs), and then **retains** `n_sites` per regulator according to the selection policy (e.g., top-score or MMR).
* Stage‑A writes the **retained pool**—the exact sites Stage‑B will draw from later. Diagnostics may compare “top-score” vs “diversified,” but the pool parquet is the single source of truth.

How to interpret common recap fields:

* **generated**: how many PWM candidates were scored (your mining budget).
* **eligible_unique**: how many unique sites survive eligibility + dedupe.
* **retained**: the final pool size for that TF (what Stage‑B will sample from).
* **tier fill**: the deepest diagnostic rung needed to collect enough candidates for the selection pool.
* **selection**: the Stage‑A retention policy (e.g., `top_score` or `mmr(alpha=…)`).
* **overlap**: how much the diversified selection overlaps the pure top-score set (MMR diagnostics).

---

### 4. Run generation

```bash
dense run -c "$CONFIG" --fresh # or --resume
```

What happens here:

* DenseGen consumes Stage‑A pools, then calls the solver to generate sequences under your plan and constraints.
* Stage‑B is the only stage that typically resamples during a run. When runtime guards trigger
  (stalls, duplicates, exhaustion), DenseGen rebuilds libraries and tries again.
* If `plots` are configured in `config.yaml`, `dense run` auto-generates them on completion.
  Use `dense run --no-plot -c "$CONFIG"` to skip auto-plotting and run `dense plot` manually.

Run guards you should be aware of:

* If `outputs/` already contains run-state or output tables, DenseGen will require you to choose:

  * `dense run --resume -c "$CONFIG"` (continue), or
  * `dense run --fresh -c "$CONFIG"` (delete `outputs/` then start over)

Debugging tips (optional flags):

* `dense run --show-tfbs -c "$CONFIG"` — include TFBS strings in progress output
* `dense run --show-solutions -c "$CONFIG"` — include full solution sequences in progress output

After the run completes, inspect the run summary:

```bash
dense inspect run --events --library -c "$CONFIG"
```

Why `dense inspect run` is worth doing:

* It summarizes generated counts, duplicates, failures, resamples, and library rebuilds.
* `--library` gives an aggregated offered-vs-used view across Stage‑B libraries (high signal when diagnosing “why am I stalling?”).
* `--events` summarizes runtime events from `outputs/meta/events.jsonl`.

---

### 5. Plot

The canonical “small but high-signal” plot set for this demo is:

```bash
# Stage‑A diagnostics (pools only)
dense plot --only stage_a_summary -c "$CONFIG"

# Stage‑B fingerprint (requires dense arrays from a completed run)
dense plot --only placement_map -c "$CONFIG"
```

What these plots tell you:

* **stage_a_summary**: pool quality (yield, score distribution, diversity diagnostics)
* **placement_map**: the run fingerprint (per-position occupancy, TF allocation, and fixed-element overlays)

If you want to discover what plots exist:

```bash
dense ls-plots -c "$CONFIG"
```

Operational note: run health is usually faster to inspect than to plot:

```bash
# dense inspect run --events --library -c "$CONFIG"
```

---

### 6. Report (optional)

```bash
dense report --plots include -c "$CONFIG"
```

Notes:

* `dense report` generates audit-grade summaries from the canonical outputs.
* `--plots include` links plots from `outputs/plots/plot_manifest.json` (so run `dense plot` first).

---

### 7. Reset the demo (optional)

If you want to rerun from scratch (keeping config + inputs intact):

```bash
dense campaign-reset -c "$CONFIG"
```

This removes the entire `outputs/` directory under the configured run root.

---

### Where outputs go

In this packaged workspace, everything is written under:

```
src/dnadesign/densegen/workspaces/demo_meme_three_tfs/outputs/
```

Common layout:

```
outputs/
  tables/
    dense_arrays.parquet
    attempts.parquet
    solutions.parquet
    composition.parquet
    run_metrics.parquet
  pools/
  libraries/
  plots/
  report/
  meta/
  logs/
```

If you’re learning the artifact model, start here:

* `outputs/tables/dense_arrays.parquet` — final sequences (canonical dataset)
* `outputs/meta/run_manifest.json` — run summary (what happened)
* `outputs/pools/pool_manifest.json` — Stage‑A summary (what got retained, and why)
* `outputs/meta/events.jsonl` — structured timeline of resamples, stalls, library builds

For full schemas and join keys, see: `../guide/outputs-metadata.md` and `../reference/outputs.md`.

---

### Common troubleshooting

#### `fimo: command not found`

DenseGen’s PWM-backed Stage‑A requires MEME Suite.
Ensure `fimo` is on PATH (or run via your environment manager that provides it).

```bash
pixi run fimo --version
```

#### Solver backend not available

Run:

```bash
dense validate-config --probe-solver -c "$CONFIG"
```

If the probe fails, either install/configure your backend (CBC / GUROBI) or adjust `densegen.solver`
in `config.yaml`.

#### “regulator group member not found” / regulator label mismatches

Your `generation.plan[].regulator_constraints.groups[].members` must match the regulator labels used in Stage‑A pools.

Run:

```bash
dense inspect inputs --show-motif-ids -c "$CONFIG"
```

Then copy the exact labels into the `regulator_constraints.groups[].members` lists.

#### Plotting issues / Matplotlib cache permissions

If Matplotlib complains about cache directories, set a writable cache path:

```bash
export MPLCONFIGDIR=/tmp/matplotlib
```

---

### Next steps

If you want the deeper “why” behind each stage:

* `../guide/sampling.md` — Stage‑A + Stage‑B sampling semantics and how to read plots
* `../guide/generation.md` — plan items, fixed elements, and solver strategy
* `../guide/inputs.md` — input types and Stage‑A PWM behavior
* `../workflows/cruncher_pwm_pipeline.md` — Cruncher → DenseGen artifact handoff
* `../reference/cli.md` — full CLI operator manual
* `../reference/config.md` — exact config schema (strict)

---

@e-south
